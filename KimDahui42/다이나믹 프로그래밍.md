# 동적 계획법

- 복잡한 문제를 간단한 여러 개의 문제로 나누어 푸는 방법
- dp는 이 메모이제이션을 통해 부분 문제의 중복계산을 방지할 수 있다
- DP는 모든 경로를 확인하기 때문에 그당시의 최선의 해를 구하는 그리디 알고리즘에 비해 시간이 걸릴 수 있다는 단점이 있지만 항상 최적의 해를 구할 수 있음
- dp는 경우의 수를 세거나 확률을 계산할 때도 흔히 사용
- 시간복잡도: dp문제는 식에 따라 시간복잡도가 달라지지만 단순하게 해당 식의 시간을 분석하는 방법은 다음과 같다

`(존재하는 부분 문제의 수)X(한 부분 문제를 풀 때 필요한 반복문의 작성횟수)`

이미 계산한 답을 사용하는 것은 상수시간이 사용되기 때문에 전체 수행 시간에 영향을 미치지 않는다

## dp가 성립하기 위한 조건

- 작은 문제들이 반복된다
- 같은 문제는 구할 때마다 값이 같다

### 1로 만들기

정수 x가 주어졌을 때, 연산 4개를 사용해 1을 만드는데 사용하는 최소 연산 횟수

```python
x=int(input())

d=[0]*30001

for i in range(2,x+1):
    d[i]=d[i-1]+1
    if i%2==0:
        d[i]=min(d[i],d[i//2]+1)
    if i%3==0:
        d[i]==min(d[i],d[i//3]+1)
    if i%5==0:
        d[i]=min(d[i],d[i//5]+1)
print(d[x])
```

### 개미전사

식량창고 N개에 대한 정보가 주어졌을 때 얻을 수 있는 식량의 최댓값

```python
n=int(input())
array=list(map(int,input().split()))

d=[0]*100

d[0]=array[0]
d[1]=max(array[0],array[1])
for i in range(2,n):
    d[i]=max(d[i-1],d[i-2]+array[i])

print(d[n-1])
```

### 효율적인 화폐 구성

n가지 종류의 화폐들의 개수를 최소한으로 이용해서 그 가치의 합이 M원이 되도록하자

```python
n,m=map(int,input().split())
array=[]
for i in range(n):
    for j in range(array[i],m+1):
        if d[j-array[i]]!=10001:
            d[j]=min(d[j],d[j-array[i]]+1)
if d[m]==10001:
    print(-1)
else:
    print(d[m])
```
